{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["App","canvasRef","useRef","imageRef","useState","diceMatrix","setDiceMatrix","numDice","setNumDice","imageSource","setImageSource","dice","getAverageRGB","data","colourSum","count","i","length","r","g","b","Math","floor","numDiceValid","width","pixelsPerDice","dicePerRow","refresh","canvas","current","context","getContext","image","height","naturalHeight","offsetHeight","naturalWidth","offsetWidth","console","log","drawImage","updateImage","tempDiceMatrix","y","diceMatrixRow","x","getImageData","averageRGB","index","push","drawDice","useEffect","diceCount","reduce","a","className","htmlFor","alt","ref","src","onLoad","type","id","accept","style","display","onChange","e","URL","createObjectURL","target","files","uploadImage","value","targetNumDice","tempNumDice","parseInt","toAdd","updateDicePerRow","min","max","textAlign","toFixed","map","row","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2f300cad.chunk.js","sourcesContent":["import './App.css';\n\nimport React, {\n  useRef,\n  useState,\n  useEffect\n} from 'react'\n\nconst App = () => {\n  const canvasRef = useRef(null);\n  const imageRef = useRef(null);\n  const [diceMatrix, setDiceMatrix] = useState([]);\n  const [numDice, setNumDice] = useState(1);\n  const [imageSource, setImageSource] = useState(\"seinfeld.jpg\");\n\n  const dice = ['⚅', '⚄', '⚃', '⚂', '⚁', '⚀']\n\n  const updateImage = () => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n\n    const image = imageRef.current;\n    canvas.height = image.naturalHeight || image.offsetHeight || image.height;\n    canvas.width = image.naturalWidth || image.offsetWidth || image.width;\n\n    console.log(`updating image ${canvas.width}x${canvas.height}`);\n    console.log(image);\n    //at this point, image isnt loaded in properly\n    context.drawImage(image, 0, 0);\n  }\n\n  const drawDice = () => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    const height = canvas.height;\n    const width = canvas.width;\n\n    if (width === 0) {\n      console.log('no draw')\n      return;\n    } else {\n      console.log('draw')\n    }\n\n    const pixelsPerDice = Math.floor(width / numDice);\n\n    let tempDiceMatrix = []\n    for (let y = 0; y < height; y += pixelsPerDice) {\n      let diceMatrixRow = [];\n      for (let x = 0; x < width; x += pixelsPerDice) {\n        const data = context.getImageData(x, y, pixelsPerDice, pixelsPerDice).data;\n        const averageRGB = getAverageRGB(data);\n        const index = Math.floor(averageRGB / 43);\n        diceMatrixRow.push(dice[index]);\n      }\n      tempDiceMatrix.push(diceMatrixRow);\n    }\n    setDiceMatrix(tempDiceMatrix);\n  }\n\n  const getAverageRGB = data => {\n    let colourSum = 0;\n    let count = 0;\n    for (let i = 0; i < data.length; i += 4) {\n      count++;\n      let r = data[i];\n      let g = data[i + 1];\n      let b = data[i + 2];\n      colourSum += Math.floor((r + g + b) / 3);\n    }\n    return Math.floor(colourSum / count);\n  }\n\n  const numDiceValid = (width, numDice) => {\n    const pixelsPerDice = Math.floor(width / numDice);\n    const dicePerRow = Math.floor(width / pixelsPerDice);\n    const totalPixelsCovered = pixelsPerDice * dicePerRow;\n\n    const fullImageCovered = totalPixelsCovered === width;\n    const diceEqualToTarget = dicePerRow === numDice;\n\n    return fullImageCovered && diceEqualToTarget;\n  }\n\n  const updateDicePerRow = targetNumDice => {\n\n    let tempNumDice = parseInt(targetNumDice);\n    const width = canvasRef.current.width;\n    const toAdd = tempNumDice > numDice ? 1 : -1;\n\n    if (width === 0) {\n      return;\n    }\n\n    while (!numDiceValid(width, tempNumDice)) {\n      tempNumDice += toAdd;\n    }\n\n    setNumDice(tempNumDice);\n  }\n\n  const refresh = () => {\n    updateImage();\n    drawDice();\n  }\n\n  useEffect(() => {\n    refresh();\n  }, [numDice])\n\n\n  const uploadImage = e => {\n    setImageSource(URL.createObjectURL(e.target.files[0]));\n  }\n\n  const diceCount = diceMatrix.reduce((count, a) => count + a.length, 0);\n\n  return (\n    <div className=\"App\">\n      <div className=\"intro\">\n        <p>Welcome to the dice art generator! Complete with price estimation in case you'd actually pay literally hundreds of pounds to put one of these monstrosities on your wall!</p>\n        <p>(Click the image to upload your own)</p>\n      <div className=\"input\">\n        <div>\n          <label htmlFor=\"image\">\n            <img\n              alt=\"whatever you uploaded\"\n              ref={imageRef}\n              height=\"100\"\n              src={imageSource}\n              onLoad={()=>refresh()}/>\n          </label>\n          <input type=\"file\"\n            id=\"image\"\n            accept=\"image/jpeg, image/png\"\n            style={{display:\"none\"}}\n            onChange={e => uploadImage(e)} />\n        </div>\n        <div className=\"options\">\n          <div>\n            <label htmlFor=\"numDice\">Number of dice per row:</label>\n            <input\n              type=\"number\"\n              id=\"numDice\"\n              value={numDice}\n              onChange={(e) => updateDicePerRow(e.target.value)}\n              min=\"1\"\n              max=\"1000\"\n              style={{textAlign:\"right\"}} />\n          </div>\n         <div>\n           <p>This image takes {diceCount} dice to create!</p>\n           <p>At 10p per dice, it'll cost ya £{(diceCount*0.1).toFixed(2)}.</p>\n         </div>\n        </div>\n      </div>\n      <canvas ref={canvasRef}  style={{display:\"none\"}} />\n    </div>\n    <div className=\"dice-holder\">\n    {  diceMatrix.map((row, i) => <div key={i}>{row}</div>) }\n    </div>\n  </div>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}